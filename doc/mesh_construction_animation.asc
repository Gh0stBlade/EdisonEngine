Mesh Construction and Animation
-------------------------------

Overview
~~~~~~~~

The animated mesh objects in the Tomb Raider series are sets of meshes that are moved relative to each other, as defined
by +Entities[]+ entries. Each entry describes which meshes to be used (a contiguous set of them referred to in
+MeshPointers[]+), what hierarchy and relative offsets they have (contents of +MeshTree[]+ pointed to), and what
animations are to be used (contents of +Animations[]+ pointed to).

The hierarchy used is a branching one, with the meshes being at the nodes, and with the first mesh being the root node.
The +MeshTree[]+ values are applied to each of the child meshes in sequence; they are sets of four ++int32_t++s, the
first being a hierarchy operator, and the remaining three being the coordinates in the parent mesh's system. A hierarchy
example is that for the Lara meshes:

[[lara_meshtree]]
image::images/illustrations/meshtree.png[title="Lara's MeshTree",width=450,float="right"]

<<lara_meshtree, The image to the right>> shows a top-down hierarchy of Lara's MeshTree. _Hips_ is a root mesh; the
ponytail is not listed, as it is a separate object.

This is implemented by using a stack of meshes and ``push'' and ``pop'' operations in +MeshTree[]+. Normally, each
mesh's parent is the previous mesh in series. But such meshes can be ``remembered'' by adding them to a stack of meshes
with a ``push'' operation. This remembered mesh can then be used as the parent mesh with a ``pop'' operation.
footnote:[It is not clear what the maximum stack depth is; most TR mesh stacks do not extend beyond 2 or 3 meshes.]

The animations for each mesh object are selected with some ingenious techniques. Which animations to use are not
hardcoded; instead, each entity has some states it can be in, and these states are used to select which animation is to
be played. For example, locks have only one state (they just sit there), doors have two states (open and closed), and
Lara has numerous states, such as standing, walking, running, jumping, falling, being hurt, dying, etc. Each animation
has a state ID, which can be used to select it; however, state transitions might seem to require a large number of
intermediate states (opening, closing, starting to jump, landing, etc.). The alternative used in the Tomb Raider engine
is for each animation to have bridge animations to other states' animations, which are selected using the ID of which
state to change to. These bridge animations then lead to the animation with the appropriate state. Thus, a closed door
will run a looped closed-door animation as long as its state stays ``closed'', but when its state becomes ``open'', it
will change to an opening-door bridge animation, which will end in a looped open-door animation. Likewise, closing a
door will make it use a closing-door bridge animation. Some bridge animations are chosen with a finer grain of
selectivity, however, such as using one for left foot forward and one for right foot forward.

Thus, each animation references a set of +StateChange+ structures, each one of which references an +AnimDispatch+
structure (called a ``range'' in some documentation). Each +StateChange+ structure contains a new state and which
+AnimDispatch+ structures to use. When an entity goes into a new state, the +StateChange+ structures are scanned for
that state's ID, and if one matches, then that +StateChange+'s +AnimDispatch+ es are then scanned for a range of frames
that contains the ID of the current frame. If such an +AnimDispatch+ is found, the animation and the frame are changed
to those listed in it.

The ultimate unit of animation is, of course, the pose, and each pose consists of a bounding box, the offset of the
root mesh, and rotation angles for all the meshes with respect to their parent meshes. The root mesh is also rotated,
but relative to the object's overall coordinates. All rotations are performed around the meshes' origins, and are in
order Y, X, Z (yaw, pitch, roll). The reason for the root mesh's displacement is because entities traveling on solid
surfaces are likely tracked by having their locations be at ground level, and Lara's hips, for example, are well above
the ground. Finally, some of the angles are not specified explicitly, when they are not, they are zero.

Poses are referenced in two ways, either by an offset into the +Poses[]+ array that contains them, or by a pose index.
The values of the latter appear to be unique to each kind of entity, but not between entities; the first pose for each
kind is numbered 0. This is likely a convenience when constructing the animations, since the list of animation poses
for each entity can be constructed separately. However, using these indices is fairly simple. Each Animation structure
has a first-pose index; this index is subtracted from the index of the desired pose in order to find out its index
relative to the animation's first pose.

There are also some special _AnimCommands_ for doing various additional things. Some of them are for moving entities in
absolute coordinates, for example to position Lara at climb location, or specifying jump momentum. Some others define
actions per frame, like playing sounds, emitting bubbles, and so forth.

Finally, some entities appear to have incomplete set of animations; their complete animations are ``borrowed'' from
similar entities. Such setup is mostly used in TR2's Venice levels -- some of Venice goons them have a full set of
animations, while some others have only the standing animation. The ones with only the standing animation borrow their
other animations from the fully-animated ones.

Data Structures
~~~~~~~~~~~~~~~

Mesh Tree Structure
^^^^^^^^^^^^^^^^^^^

[[tr_meshtree_node]]
[source,cpp]
----
struct tr_meshtree_node // 4 bytes
{
    uint32_t stackOperation;
     int32_t Offset_X;
     int32_t Offset_Y;
     int32_t Offset_Z;
};
----

+MeshTree[]+ array consists of meshtree nodes.

By default, the meshes' parents are always initialized to their predecessors; for the first mesh, this is implicitly its
skeleton. Also, the first mesh's +stackOperation+ should _always_ be considered to be ``Push''.

After initializing the parents to their defaults, the stack operations are applied:

.Stack operations
[horizontal]
Use Predecessor (0)::
    The most recently processed mesh is the parent of the current mesh.  This operation is invalid if the current mesh
    is the first being processed.
Push (1)::
    Push the current mesh's parent onto the stack.
Pop (2)::
    Pop a mesh from the stack and assign it as the current mesh's parent. This operation is invalid if the stack is
    empty.
Top (3)::
    Same as ``Pop'', but do not pop the mesh from the stack.

+Offset_X+, +Offset_Y+ and +Offset_Z+ are offsets of the mesh's origin from the parent mesh's origin.

TR1-3 Animation Structure
^^^^^^^^^^^^^^^^^^^^^^^^^

This describes each individual animation. These may be looped by specifying the next animation to be itself.

CAUTION: {TR2} {TR3} In TR2 and TR3, one must be careful when parsing poses using the +poseDataSize+ as the size of each pose, since
an animation's pose data may extend into the next animation's pose data, and that may have a different +poseDataSize+
value.

[[tr_animation]]
[source,cpp]
----
struct Animation // 32 bytes
{
    uint32_t  poseDataOffset;
     uint8_t  stretchFactor;
     uint8_t  poseDataSize;   // Number of int16_t's in PoseData[] used by this animation

    uint16_t  stateId;

       fixed  speed;
       fixed  accelleration;

    uint16_t  firstFrame;   // First frame in this animation
    uint16_t  lastFrame;    // Last frame in this animation
    uint16_t  nextAnimation;
    uint16_t  nextFrame;

    uint16_t  NumStateChanges;
    uint16_t  StateChangeOffset; // Offset into StateChanges[]

    uint16_t  animationCommandCount;   // How many of them to use.
    uint16_t  animationCommandsOffset; // Offset into AnimationCommand[]
};
----

[horizontal]
+poseDataOffset+::
    Byte offset into +PoseData[]+ (divide by 2 for +PoseData[i]+).

+stretchFactor+::
    Multiplier value which defines how many _game frames_ will be spent for each actual animation frame. For example, if
    it is 1, then each animation frame belongs to a single game frame. If the value is 2, then each animation frame
    lasts two game frames, and so on. In the latter case, animation frames will be interpolated between game frames
    using the _slerp_ function. footnote:[See https://en.wikipedia.org/wiki/Slerp for a mathematical explanation.]

+stateId+::
    Identifies current state type to be used with this animation. The Engine uses the current +stateId+ not only to
    solve state changes, but also to define Lara's current behaviour -- like collisional routines to be used, controls
    to be checked, health/air/sprint points to be drained, and so on.

+speed+ and +accelleration+::
    Used to set a specific momentum to a given entity. That is, the entity will be accelerated with the +accelleration+
    value, until the +speed+ value is reached. If +accelleration+ is negative, the speed will be decreased to fit the
    +speed+ value. The direction in which the entity is moved using the +speed+ value is hardcoded, and is mostly
    forward.

+nextAnimation+::
    Defines which animation should be played after the current one is finished. When the current animation ends, the
    engine will switch to +nextAnimation+, not regarding current +stateId+ value. If the +nextAnimation+ value is the
    same as the animation number itself, it means that the animation will be looped until the loop is broken by some
    state change.

+nextFrame+::
    Specifies the frame number to be used when switching to the next animation. For example, if +nextFrame+ is 5 and
    +nextAnimation+ is 20, it basically means that at the end of the current animation the engine will switch right to
    frame 5 of animation 20. If the animation is looped, +nextFrame+ defines to which frame the animation should be
    rewound. It allows to ``eat up'' certain start-up frames of some animations and re-use them as loops.

NOTE: The actual game frame rate is always locked to 30 FPS. All engine internal counters, including animation frame
counters, are also using 30 FPS timebase.

TIP: The animation length in frames is equal to +length = (lastFrame - firstFrame) + 1+.

TR4-5 Animation Structure
^^^^^^^^^^^^^^^^^^^^^^^^^

{TR4} {TR5} For TR4 and TR5, an extended version of <<tr_animation, +Animation+>> is used. In addition to +speed+ and
+accelleration+ values, TR4 introduced _lateral_ values, which are used to move the entity to the sides, rather than
forward or backward. However, these values are only used for _any entity but Lara_ -- the engine ignores them in such a
case.

Lateral speed and acceleration are primarily used for ``start-up'' animations of NPCs -- for example, armed baddies in
TR4 can roll or jump aside.

[[tr4_animation]]
[source,cpp]
----
struct TR4Animation // 40 bytes
{
    // ... same as before ...
       fixed  speed;
       fixed  accelleration;

    // New fields
       fixed  lateralSpeed;
       fixed  lateralAccelleration;

    uint16_t  firstFrame;
    uint16_t  lastFrame;

    // ... same as before ...
};
----

Transitions
^^^^^^^^^^^

Each transition case collection entry contains the state to change to and which <<tr_transitioncase, transition cases>>
to use; there may be more than one, with each separate one covering a different range of frames.

[[tr_transitions]]
[source,cpp]
----
struct Transitions // 6 bytes
{
    uint16_t stateId;
    uint16_t transitionCaseCount; // number of transition cases (seems to always be 1..5)
    uint16_t firstTransitionCase; // Offset into TransitionCases[]
};
----

Transition Cases
^^^^^^^^^^^^^^^^

This specifies the next <<tr_animation, animation>> and frame to use; these are associated with some range of frames.
This allows, for example, to specify different target animations depending on which of Lara's feet is currently in
front.

[[tr_transitioncase]]
[source,cpp]
----
struct TransitionCase // 8 bytes
{
    int16_t firstFrame;      // Frame range this case applies to
    int16_t lastFrame;
    int16_t targetAnimation; // Animation to dispatch to
    int16_t targetFrame;     // Frame offset to dispatch to
};
----

AnimationCommand Structure
^^^^^^^^^^^^^^^^^^^^^^^^^^

These are various commands associated with each animation. They are varying numbers of ++int16_t++s packed into an
array. Just like the <<tr_floordata,FloorData>>, AnimationCommands must be parsed sequentially, one by one.

The first AnimationCommand entry is the _opcode_, which also determines how many parameters follow (i.e., how many
+int16_t+ values must be parsed without switching to the next AnimationCommand). For a given <<tr_animation,
animation>>, there are +Animation::animationCommandCount+ commands.

Some of commands refer to the whole animation (jump speed, position change and empty hands commands), while others are
associated with specific frames (sound, bubbles, etc.).

[[tr_animationcommand]]
[source,cpp]
----
struct AnimationCommand // 2 bytes
{
    int16_t value;
};
----

.AnimationCommand opcodes
+1+ -- Set Position (3 parameters)::
    Sets relative entity position (x, y, z); found in grab and block-move animations.
+2+ -- Set Velocity (2 parameters)::
    Vertical and horizontal speed for jumping.
+3+ -- Empty Hands (no parameters)::
    This command is performed in the end of animation of Lara pulling a switch, inserting a key, grabbing a pushable
    block, and so on. It is needed because engine ``locks'' Lara's ability to draw weapons or ignite a flare when such
    action is performed, and only way to unlock it is to call this command.
+4+ -- Kill (no parameters)::
    Kill entity. This effectively disables the entity and removes it from the world.
+5+ -- Play Sound (2 parameters)::
    The first argument is a frame number, and the second one is the ID of the sound to play at that frame (internal
    sound index).
    +
    {TR2}{TR3}{TR4}{TR5} In TR2 and above, besides Sound ID, the second parameter may contain two
    ``packed'' bit flags (see below).
+6+ -- Play Effect (2 parameters)::
    The first parameter is a frame number, and the second one is the effect number. Note that _effect_ here is the very
    same kind of effect used in _trigger action_ with the same name. The effect meanings will be listed separately.
+7+ -- Interact (?? parameters)::
    ??

.``Play Sound'' Sound ID bitflags
[horizontal]
+0x4000+::
    play this sound when on dry land (example: footsteps)
+0x8000+::
    play this sound when in water (example: running through shallow water)

Pose Structure
^^^^^^^^^^^^^^
Poses indicate how composite meshes are positioned and rotated. They work in conjunction with <<tr_animation,
+Animations[]+>> and +MeshTree[]+. A given pose has the following format:

[[tr_pose]]
[source,cpp]
----
struct Vertex
{
    int16_t x, y, z;
};

struct BoundingBox
{
    Vertex first;
    Vertex second;
};

virtual struct Pose
{
  BoundingBox  boundingBox;
       Vertex  offset; // Starting offset for this model
      int16_t  angleSetCount;
     uint16_t  values[]; // variable size
};
----

[horizontal]
+angleSetCount+::
    {TR1} Number of angle sets to follow; these start with the first mesh, and meshes without angles get zero angles. +
    {TR2}{TR3}{TR4}{TR5} +angleSetCount+ is implicitly +meshCount+ (from model).

+values+::
    Sets of rotation angles for all the meshes with respect to their parent meshes.

TIP: Since TR2, an angleset can specify either one or all three axes of rotation. The highest two bits of the first
angleset value are the _axis selector_; for TR1, this selector should _always_ be considered 0.

.Angleset axis selector values
* +0+ -- All axes, in compressed format (see below).
* +1+ -- X only
* +2+ -- Y only
* +3+ -- Z only

For single-axis angles, the lower 10 bits of the first angleset value indicate a rotation with a value range
latexmath:[$ [0; 1024[ $], which is scaled to latexmath:[$ [0; 360[ $] degrees. The compressed three-axis rotation
mentioned above uses one more angleset element, using the full latexmath:[$10 \cdot 3$] bits available. The binary
layout of the two +uint16_t+'s is: +**xx xxxx xxxx yyyy | yyyy yyzz zzzz zzzz+.

[CAUTION]
====
{TR1} In TR1, the word order of the angleset values is reversed: +yyyy yyzz zzzz zzzz | **xx xxxx xxxx yyyy+

{TR4}{TR5} In TR4 and above, single-axis angles (where the axis selector is not zero) have a higher precision of 12 bits
instead of 10 bits, with the value range latexmath:[$[0; 4096[$] mapped to latexmath:[$[0; 360[$] degrees.
====

NOTE: Rotations are performed in Y, X, Z order.
